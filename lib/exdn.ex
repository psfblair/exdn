defmodule Exdn do
  @moduledoc """
  Exdn is a two-way translator between Elixir data structures and data
  following the [edn specification](https://github.com/edn-format/edn);
  it wraps the [erldn edn parser](https://github.com/marianoguerra/erldn)
  for Erlang, with some changes in the data formats.

  ## Examples

      iex> Exdn.to_elixir! "[1 :foo]"
      [1, :foo]

      iex> Exdn.to_elixir "{1 :foo, 2 :bar}"
      {:ok, %{1 => :foo, 2 => :bar}}

      iex> Exdn.from_elixir! %{1 => :foo, 2 => :bar}
      "{1 :foo 2 :bar}"

      iex> Exdn.from_elixir %{:foo => {:char, ?a}, {:char, ?b} => {:tag, :inst, "1985-04-12T23:20:50.52Z"} }
      {:ok, "{:foo \\a \\b #inst \"1985-04-12T23:20:50.52Z\"}" }

  ## Type mappings:

    edn	              | Elixir generated by `to_elixir` functions (when no custom converter is provided)
    ---------------   | -----------------------------------------
    integer	          | integer
    float	            | float
    boolean	          | boolean
    nil	              | nil (atom)
    char              | string
    string	          | string
    list	            | tagged list `{:list, [...]}`
    vector	          | list
    map	              | map
    set	              | mapset
    symbol	          | tagged atom `{:symbol, atom}`
    tagged elements	  | call registered handler for that tag, fail if not found

    Elixir accepted by `from_elixir` functions              | edn
    -----------------------------------------------------   | ---------------
    integer                                                 | integer
    float                                                   | float
    boolean                                                 | boolean
    nil (atom)                                              | nil
    tagged integer `{:char, <integer>}`                     | char
    string                                                  | string
    tagged list `{:list, [...]}`                            | list
    list                                                    | vector
    map                                                     | map
    struct                                                  | map
    mapset                                                  | set
    tagged atom `{:symbol, atom}`                           | symbol
    tagged tuple with tag and value `{:tag, Symbol, Value}` | tagged elements
  """

  alias Calendar.DateTime.Parse

  @type exdn ::
          atom | boolean | number | String.t() | tuple | [exdn] | %{exdn => exdn} | MapSet.t()
  @type handler :: (atom, term, (exdn -> exdn), [{atom, handler}] -> exdn)

  @doc """
     parses an edn string into an Elixir data structure; this is not a reversible
     conversion as chars are converted to strings, and tagged expressions are
     interpreted. This function can throw exceptions; for example, if a tagged
     expression cannot be interpreted.

     The second (optional) argument

     The third (optional) argument allows you to supply your own handlers for
     the interpretation of tagged expressions. These should be in the form of a
     keyword list. The first element of each pair should be a keyword corresponding
     to the tag, and the second element a function of three parameters
     (tag, value, handlers) that handles the tagged values.

     The one-argument version provides default handlers for #inst and #uuid.

  ## Examples:
      iex> Exdn.to_elixir! "41.2"
      41.2

      iex> Exdn.to_elixir! ":foo"
      :foo

      iex> Exdn.to_elixir! "true"
      true

      iex> Exdn.to_elixir! "nil"
      nil

      iex> Exdn.to_elixir! "\"asd\""
      "asd"

      # Char
      iex> Exdn.to_elixir! "\\a"
      "a"

      # Symbol
      iex> Exdn.to_elixir! "foo"
      {:symbol, :foo}

      # edn vectors become Elixir lists:
      iex> Exdn.to_elixir! "[1 :foo]"
      [1, :foo]

      # edn lists are always tagged. Since Datomic is a principal use of edn, and since lists are
      # used in Datomic primarily for executable expressions rather than as data structures, we
      # use Elixir lists to represent vectors and keep edn lists specially tagged:
      iex> Exdn.to_elixir! "(1, :foo)"
      {:list, [1, :foo]}

      # edn sets become Elixir sets:
      iex> Exdn.to_elixir! "\#{1 \\a 1}"
      #MapSet<[1, "a"]>

      # Maps become Elixir maps:
      iex> Exdn.to_elixir! "{1 :foo, 2 :bar}"
      %{1 => :foo, 2 => :bar}

      # You can also transform maps to Elixir structs by providing your own converter in the second argument:
      iex> defmodule FooStruct do
      ...>    defstruct foo: "default"
      ...> end
      iex> converter = fn map ->
      ...>    case map do
      ...>       %{:foo => _} -> struct(FooStruct, map)
      ...>       anything_else -> anything_else
      ...>     end
      ...>   end
      iex>  Exdn.to_elixir! "{:foo 1, :bar 2}", converter
      %FooStruct{foo: 1}

      # Tagged expressions are converted. Standard converters for #inst and #uuid are included:
      iex> Exdn.to_elixir! "#inst \"1985-04-12T23:20:50.52Z\""
      %Calendar.DateTime{abbr: "UTC", day: 12, hour: 23, min: 20, month: 4, sec: 50,
        std_off: 0, timezone: "Etc/UTC", usec: 520000, utc_off: 0, year: 1985}

      iex> Exdn.to_elixir! "#uuid \"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\""
      "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"

      # You can provide your own handlers for tagged expressions:
      iex> handler = fn(_tag, val, _handlers) -> val <> "-converted" end
      iex> Exdn.to_elixir! "#foo \"blarg\"", [{:foo, handler}]
      "blarg-converted"
  """
  @spec to_elixir!(String.t(), (exdn -> exdn), [{atom, handler}, ...]) :: exdn
  def to_elixir!(edn_str, converter \\ fn x -> x end, handlers \\ standard_handlers) do
    erlang_str = edn_str |> to_char_list
    {:ok, erlang_intermediate} = :erldn.parse_str(erlang_str)
    elrldn_to_elixir!(erlang_intermediate, converter, handlers)
  end

  @doc """
   parses an edn string into an Elixir data structure, but does not throw
   exceptions. The parse result is returned as the second element of a pair
   whose first element is `:ok` -- if there is an error the first element will
   be `:error` and the second the error that was raised.

  ## Examples:

      iex> Exdn.to_elixir "{1 :foo, 2 :bar}"
      {:ok, %{1 => :foo, 2 => :bar}}

      iex> Exdn.to_elixir "{:foo, \\a, \\b #foo \"blarg\" }"
      {:error, %RuntimeError{:message => "Handler not found for tag foo with tagged expression blarg"}}
  """
  @spec to_elixir(String.t(), (exdn -> exdn), [{atom, handler}, ...]) ::
          {:ok, exdn} | {:error, term}
  def to_elixir(edn_str, converter \\ fn x -> x end, handlers \\ standard_handlers) do
    {:ok, to_elixir!(edn_str, converter, handlers)}
  rescue
    e -> {:error, e}
  end

  defp elrldn_to_elixir!({:char, char}, converter, _handlers) do
    case converter.({:char, char}) do
      {:char, char} -> to_string([char])
      anything_else -> anything_else
    end
  end

  defp elrldn_to_elixir!({:keyword, nil}, converter, _handlers), do: converter.(nil)

  defp elrldn_to_elixir!({:tag, tag, val}, converter, handlers) do
    case converter.({:tag, tag, val}) do
      {:tag, atag, aval} ->
        converted_val = elrldn_to_elixir!(aval, converter, handlers)
        evaluate_tagged_expr({:tag, atag, converted_val}, converter, handlers)

      anything_else ->
        anything_else
    end
  end

  defp elrldn_to_elixir!({:vector, items}, converter, handlers) do
    Enum.map(items, fn item -> elrldn_to_elixir!(item, converter, handlers) end)
    |> (fn x -> converter.(x) end).()
  end

  defp elrldn_to_elixir!({:set, items}, converter, handlers) do
    convert_set(items, fn x -> elrldn_to_elixir!(x, converter, handlers) end)
    |> (fn x -> converter.(x) end).()
  end

  defp elrldn_to_elixir!({:map, pairs}, converter, handlers) do
    convert_map(pairs, fn x -> elrldn_to_elixir!(x, converter, handlers) end)
    |> (fn x -> converter.(x) end).()
  end

  defp elrldn_to_elixir!(items, converter, handlers) when is_list(items) do
    {:list,
     Enum.map(items, fn item -> elrldn_to_elixir!(item, converter, handlers) end)
     |> (fn x -> converter.(x) end).()}
  end

  defp elrldn_to_elixir!(val, converter, _handlers), do: converter.(val)

  @doc """
    parses an edn string into an Elixir data structure, but in a reversible way --
    chars and tagged expressions are represented using tuples whose first element
    is `:char` or `:tag`, respectively.

  ## Examples:
      iex> Exdn.to_reversible( "\\a" )
      {:char, ?a}

      iex> Exdn.to_reversible "#inst \"1985-04-12T23:20:50.52Z\""
      {:tag, :inst, "1985-04-12T23:20:50.52Z"}

      # An unknown tag raises no error when using the reversible conversion:
      iex> Exdn.to_reversible "#foo \"blarg\""
      {:tag, :foo, "blarg"}
  """
  @spec to_reversible(String.t()) :: exdn
  def to_reversible(edn_str) do
    erlang_str = edn_str |> to_char_list
    {:ok, erlang_intermediate} = :erldn.parse_str(erlang_str)
    reversible(erlang_intermediate)
  end

  defp reversible({:char, char}), do: {:char, char}
  defp reversible({:keyword, nil}), do: nil
  defp reversible({:tag, tag, val}), do: {:tag, tag, val}
  defp reversible({:vector, items}), do: Enum.map(items, fn item -> reversible(item) end)
  defp reversible({:set, items}), do: convert_set(items, fn x -> reversible(x) end)
  defp reversible({:map, pairs}), do: convert_map(pairs, fn x -> reversible(x) end)

  defp reversible(items) when is_list(items),
    do: {:list, Enum.map(items, fn item -> reversible(item) end)}

  defp reversible(val), do: val

  defp convert_map(pairs, converter) do
    convert_pair = fn {key, val} -> {converter.(key), converter.(val)} end
    pairs |> Enum.map(convert_pair) |> Map.new()
  end

  defp convert_set(items, converter) do
    convert_item = fn item -> converter.(item) end
    items |> Enum.map(convert_item) |> MapSet.new()
  end

  @doc """
    converts an Elixir data structure in the "reversible" format (see below) into
    an edn string. Will raise exceptions if the data structure cannot be converted.

  ## Examples:

      # The intermediate representation can be converted back to edn:

      iex> Exdn.from_elixir! 41.2
      "41.2"

      iex> Exdn.from_elixir! :foo
      ":foo"

      iex> Exdn.from_elixir! true
      "true"

      iex> Exdn.from_elixir! nil
      "nil"

      iex> Exdn.from_elixir! "asd"
      "\"asd\""

      iex> Exdn.from_elixir! {:char, ?a}
      "\\a"

      iex> Exdn.from_elixir! {:symbol, :foo}
      "foo"

      iex> Exdn.from_elixir! [1, :foo]
      "[1 :foo]"

      iex> Exdn.from_elixir! {:list, [1, :foo]}
      "(1 :foo)"

      iex> Exdn.from_elixir! MapSet.new([1, :foo])
      "\#{1 :foo}"

      iex> Exdn.from_elixir! %{1 => :foo, 2 => :bar}
      "{1 :foo 2 :bar}"

      iex> Exdn.from_elixir! %SomeStruct{foo: 1, bar: 2}
      "{:foo 1 :bar 2}"

      iex> Exdn.from_elixir! {:tag, :inst, "1985-04-12T23:20:50.52Z"}
      "#inst \"1985-04-12T23:20:50.52Z\""
  """
  @spec from_elixir!(exdn) :: String.t()
  def from_elixir!(elixir_data) do
    erldn_intermediate = to_erldn_intermediate(elixir_data)
    :erldn.to_string(erldn_intermediate) |> to_string
  end

  @doc """
    safe version of `from_elixir!/1` -- the edn string is returned as the second
    element of a pair whose first element is `:ok` -- if there is an error the first
    element will be `:error` and the second the error that was raised.

  ## Example:

      iex> Exdn.from_elixir %{:foo => {:char, ?a}, {:char, ?b} => {:tag, :inst, "1985-04-12T23:20:50.52Z"} }
      {:ok, "{:foo \\a \\b #inst \"1985-04-12T23:20:50.52Z\"}" }
  """
  @spec from_elixir(exdn) :: {:ok, String.t()} | {:error, term}
  def from_elixir(elixir_data) do
    {:ok, from_elixir!(elixir_data)}
  rescue
    e -> {:error, e}
  end

  defp to_erldn_intermediate(items) when is_list(items) do
    {:vector, Enum.map(items, fn x -> to_erldn_intermediate(x) end)}
  end

  defp to_erldn_intermediate({:list, items}) do
    Enum.map(items, fn x -> to_erldn_intermediate(x) end)
  end

  defp to_erldn_intermediate(%MapSet{} = set) do
    items = Enum.map(set, fn x -> to_erldn_intermediate(x) end)
    {:set, items}
  end

  # Works on structs or maps
  defp to_erldn_intermediate(pairs) when is_map(pairs) do
    convert_pair = fn {key, val} -> {to_erldn_intermediate(key), to_erldn_intermediate(val)} end
    keyword_list = pairs |> to_map |> Enum.map(convert_pair)
    {:map, keyword_list}
  end

  defp to_erldn_intermediate({:tag, tag, val}), do: {:tag, tag, to_erldn_intermediate(val)}

  defp to_erldn_intermediate(val), do: val

  defp to_map(struct_or_map) do
    case struct_or_map do
      %{__struct__: _} -> Map.from_struct(struct_or_map)
      _ -> struct_or_map
    end
  end

  @doc """
    extracts a list from the tagged reversible representation; does not operate at all
    on the contents of the extracted list.

  ## Example:

      iex> Exdn.tagged_list_to_list {:list, [:foo]}
      [:foo]
  """
  @spec tagged_list_to_list({:list, [term]}) :: term
  def tagged_list_to_list({:list, list}), do: list

  @doc """
    extracts a char (as a string) from the tagged reversible representation.

  ## Example:

      iex> Exdn.tagged_char_to_string {:char, ?a}
      "a"
  """
  @spec tagged_char_to_string({:char, [integer]}) :: String.t()
  def tagged_char_to_string({:char, code}), do: to_string([code])

  @doc """
    interprets a tagged expression using the tagged reversible representation and
    handlers passed in as a keyword list. Assumes the expression inside the tag has
    already been translated from edn.

  ## Example:

      iex> tagged = {:tag, :foo, "blarg"}
      iex> handler = fn(_tag, val, _converter, _handlers) -> val <> "-converted" end
      iex> Exdn.evaluate_tagged_expr(tagged, [{:foo, handler}]
      "blarg-converted"
  """
  @spec evaluate_tagged_expr({:tag, atom, exdn}, (exdn -> exdn), [{atom, handler}, ...]) :: exdn
  def evaluate_tagged_expr({:tag, tag, expr}, converter, handlers) do
    handler = handlers[tag]

    if handler do
      handler.(tag, expr, converter, handlers)
    else
      expr_string = inspect(expr)
      raise "Handler not found for tag #{tag} with tagged expression #{expr_string}"
    end
  end

  @doc """
     handlers for standard edn tagged expressions #inst and #uuid. If you need to supply
     your own custom handlers for other tags, you may wish to append them to this list of
     handlers.
  """
  @spec standard_handlers() :: [{:inst, handler} | {:uuid, handler}, ...]
  def standard_handlers do
    timestamp_handler = {:inst, fn _tag, val, _converter, _handlers -> inst_handler(val) end}
    uuid_handler = {:uuid, fn _tag, val, _converter, _handlers -> val |> to_string end}
    # TODO Discard Handler This shouldn't return nil; it should swallow the val.
    # discard_handler = { :_, fn(tag, val, _converter, _handlers) -> ??? end }
    [timestamp_handler, uuid_handler]
  end

  defp inst_handler(char_list) do
    {:ok, result} = char_list |> to_string |> Parse.rfc3339_utc()
    result
  end
end
